/* This code is based on  * Ilario Mazzei tetris application * Contact email: m360@libero.it * */import mx.events.EventDispatcher;import utils.*;class Tetris.Level extends MovieClip{	public var dispatchEvent:Function;	public var addEventListener:Function;	public var removeEventListener:Function;		private var KUp:Number = Key.UP;	private var KDown:Number=Key.DOWN;	private var KLeft:Number=Key.LEFT;	private var KRight:Number=Key.RIGHT;	private var KDrop:Number=Key.SPACE;	private var KeyPause:String="P";	var ToPause:Boolean=false;	var ToStop:Boolean=false;	private var nLevel:Number;	private var lScore:Number = 0;	private var vLines:Number = 0;	private var Matrix= new Array(22);	private var TState:Number;	private var pModeAnyKey:Boolean = false;	private var pflag:Boolean = false;		private var Levels:Tetris.LevelType;	var accelerate:Boolean=true;	private var nBlock:Number = 1;	private var cBlock:Boolean=false;		private var Blocks:Tetris.BlockType;	private var NextBlock:Number;	private var offL:Array;	private var offC:Array;	private var color:String;	private var cLine:Number;	private var cCol:Number;	private var bState:Number;//see details in Tetris.BlockType	private var LinesToDel:Array;	private var transictionEnd:Boolean;	private var TimerDown:Timer;	private var TimerAlpha:Timer;	var dBrick:Number=15;		function Level(){		EventDispatcher.initialize(this);	}		function initApp(initobj:Object){			Blocks=new Tetris.BlockType();			Levels=new Tetris.LevelType();			LinesToDel=new Array();			TimerDown=new Timer();			TimerAlpha=new Timer(initobj._delayAlpha);			KeyTime.setKT(initobj);	}		function initLevel(_nLevel:Number):Boolean{	  if (_nLevel == 1)	  {			lScore = 0;			nBlock = 1;			vLines = 0;			this.dispatchEvent({type:"onStart", target:_parent});			NextBlock = GetRandomBlock();			clearLevel();	  }		ToStop = ToPause = pflag = false;		TState = 0;		nLevel = _nLevel;		bState = 0;				cBlock = false;				Levels.GetLevel(nLevel, accelerate);		TimerDown.setDelay(Levels._Delay);				this.dispatchEvent({type:"onInitLevel", target:_parent, level:nLevel});		return(true);	}		private function clearLevel()	{	  var i,j:Number;		for(i=0;i<22;i++){			if(Matrix[i]==undefined)Matrix[i]=(new Array(10));			for(j=0;j<10;j++){				if(Matrix[i][j]>0) eval("this.brick"+Matrix[i][j]).removeMovieClip();				Matrix[i][j]=0;			}		}		if(Blocks!=undefined)			for(i=0;i<Blocks.iMatrix[0];i++)				for(j=0;j<Blocks.iMatrix[1];j++)					if(Blocks.bMatrix[i][j])						eval("this.brick"+Blocks.bMatrix[i][j]).removeMovieClip();	}				private function runBlocks(){			var i:Number;		updateAfterEvent();		switch(TState){			case 0:// crea i blocchi, li fa scorrere e li posa				if(!cBlock){ 					if(initBlock())					{						TimerDown.TReset();					}					else {					  ToStop = true;						TState = 3;						break;					}				}				evalKey(getKey());				if (i != 2){					if (TimerDown.cTime()){						ShiftDown();					}				}				break;			case 1:// Transizione righe				doTransition();				break;			case 2://pause				if (pModeAnyKey || getKey() == 5){					TState = 0;					pflag = false;					this.dispatchEvent({type:"onEndPause", target:_parent});				}				break;			case 3:// Game over				this.dispatchEvent({type:"onGameOver", target:_parent, score: lScore});				this.onEnterFrame=undefined;				break;			case 4:// Game win				this.dispatchEvent({type:"onWin", target:_parent});				this.onEnterFrame=undefined;				break;							case 5://Init new Level				initLevel(nLevel+1);				//eval(_target+".sNextBlock").gotoAndStop(NextBlock);				break;		}	}			private function evalKey(i:Number){		switch(i){			case 1:				Rotate();				break;			case 2:				ShiftDown();				break;			case 3:				ShiftLR("left");				break;			case 4:				ShiftLR("right");				break;			case 5:				this.dispatchEvent({type:"onPause", target:_parent});				TState=2;				pflag=true;				break;			case 7://drop key				TimerDown.setDelay(1);				break;		}	}		private function doTransition(){		var i,j,k,bAlpha:Number;		if(transictionEnd == false){			bAlpha=eval("this.brick"+Matrix[LinesToDel[0]][0])._alpha;			if(bAlpha>10){				if(TimerAlpha.cTime())					for(i=0;i<LinesToDel.length;i++)						for(j=0;j<10;j++)							eval("this.brick"+Matrix[LinesToDel[i]][j])._alpha-=10;			}else{				k=0;				for(i=LinesToDel[0];i<22;i++){					if((i==LinesToDel[k])&&(k<LinesToDel.length)){						for(j=0;j<10;j++) 							eval("this.brick"+Matrix[i][j]).removeMovieClip();														k++;					}else{						if(i==21){							for(j=0;j<10;j++) Matrix[i-k][j]=0;						}else{							for(j=0;j<10;j++) 								Matrix[i-k][j]=Matrix[i][j];						}						for(j=0;j<10;j++){							eval("this.brick"+Matrix[i-k][j])._y+=dBrick*k;						}					}				}				transictionEnd=true;				this.dispatchEvent({type:"onLinesDeleted", target:_parent, lines:LinesToDel.length});			}		} else {		  if (lScore > Levels.scoreToGo) TState = 5;		  else TState = 0;		}	}		private function Rotate(){		var i,j,k,dist:Number;		var canRotate:Boolean=true;		var lbMatrix,liMatrix:Array;		lbMatrix=new Array(Blocks.iMatrix[1]);		liMatrix=new Array(3);		for(i=Blocks.iMatrix[1]-1;i>=0;i--){			lbMatrix[Blocks.iMatrix[1]-1-i]=new Array(Blocks.iMatrix[0]);			for(j=0;j<Blocks.iMatrix[0];j++)				lbMatrix[Blocks.iMatrix[1]-1-i][j]=Blocks.bMatrix[j][i];		}		liMatrix[0]=Blocks.iMatrix[1];		liMatrix[1]=Blocks.iMatrix[0];		canRotate=checkBlock(cLine+offL[bState],cCol+offC[bState],lbMatrix,liMatrix);		if(canRotate){			cLine+=offL[bState];			cCol+=offC[bState];		}else{			dist=10;			j=k=cCol;			for(i=cCol;i>=0;i--)				if(Matrix[cLine+offL[bState]][i]==0) k=i;				else i=-1;			for(i=cCol;i<10;i++)				if(Matrix[cLine+offL[bState]][i]==0) j=i;				else i=10;			for(i=k;i<j;i++)				if(checkBlock(cLine+offL[bState],i,lbMatrix,liMatrix))					if(Math.abs(cCol+offC[bState]-i)<Math.abs(dist)){						dist=cCol+offC[bState]-i;						canRotate=true;					}			if(canRotate){				cLine+=offL[bState];				cCol=cCol+offC[bState]-dist;			}		}		if(canRotate){			(bState==3)?bState=0:bState++;			for(i=0;i<liMatrix[0];i++)				for(j=0;j<liMatrix[1];j++)					if (lbMatrix[i][j]){						eval("this.brick"+lbMatrix[i][j])._x=dBrick*(cCol+j);						eval("this.brick"+lbMatrix[i][j])._y=dBrick*(21-(cLine+i));					}			Blocks.bMatrix=lbMatrix;			Blocks.iMatrix=liMatrix;		}	}		private function ShiftLR(BDirection:String){		var i,j,dir:Number;		var NextFree:Boolean=true;		(BDirection=="left")?dir=-1:dir=1;		if(BDirection=="left"){			if (cCol==0) NextFree=false;		}else if (cCol==10) NextFree=false;		if(NextFree==true)			NextFree=checkBlock(cLine,cCol+dir,Blocks.bMatrix,Blocks.iMatrix);		if(NextFree==true){			for(i=0;i<Blocks.iMatrix[0];i++)				for(j=0;j<Blocks.iMatrix[1];j++)					if(Blocks.bMatrix[i][j])						eval("this.brick"+Blocks.bMatrix[i][j])._x+=dBrick*dir;			cCol+=dir;		}	}			private function ShiftDown(){		var i,j:Number;		var NextFree:Boolean=true;		if(cLine!=0) NextFree=checkBlock(cLine-1,cCol,Blocks.bMatrix,Blocks.iMatrix);		if((cLine==0)||(NextFree==false)){			for(i=0;i<Blocks.iMatrix[0];i++)				for(j=0;j<Blocks.iMatrix[1];j++)					if(Blocks.bMatrix[i][j])						Matrix[cLine+i][cCol+j]=Blocks.bMatrix[i][j];			cBlock=false;			checkLines(cLine,cLine+Blocks.iMatrix[0]-1);			KeyTime.Reset();			TimerDown.setDelay(Levels._Delay);		}		else if(NextFree==true){				for(i=0;i<Blocks.iMatrix[0];i++)					for(j=0;j<Blocks.iMatrix[1];j++)						if(Blocks.bMatrix[i][j])							eval("this.brick"+Blocks.bMatrix[i][j])._y+=dBrick;			 	cLine--;			 }	}			private function checkLines(L1:Number,L2:Number){		var i,j:Number;		var insLine:Boolean;		LinesToDel.length=0;		for(i=L1;i<=L2;i++){			insLine=true;			for(j=0;j<10;j++)				if(Matrix[i][j]==0) insLine = false;			if(insLine) LinesToDel.push(i);		}		if(LinesToDel.length>0){			vLines += LinesToDel.length;			lScore += [40, 100, 300, 1200][LinesToDel.length - 1] * (1 + (nLevel - 1) * 0.2);			TimerAlpha.TReset();			transictionEnd = false;			TState = 1;		} else {		  lScore += 10;		  if (lScore > Levels.scoreToGo) TState = 5;		}	}		private function initBlock():Boolean{		var i,j:Number;		Blocks.GetBlock(NextBlock);		NextBlock = GetRandomBlock();		eval(_target+".sNextBlock").gotoAndStop(NextBlock);		color=Blocks.bColor;		offL=Blocks.bOffL;		offC=Blocks.bOffC;		if(!checkBlock(22-Blocks.iMatrix[0],3,Blocks.bMatrix,Blocks.iMatrix))			return false;		for(i=0;i<Blocks.iMatrix[0];i++)			for(j=0;j<Blocks.iMatrix[1];j++)				if(Blocks.bMatrix[i][j]){					Blocks.bMatrix[i][j]=nBlock;					attachMovie("asBrick","brick"+nBlock,nBlock);					eval("this.brick" + nBlock)._x = dBrick*(j+3);					eval("this.brick" + nBlock)._y = dBrick*(Blocks.iMatrix[0]-1-i);					eval("this.brick" + nBlock).gotoAndStop(color);					(nBlock>3000) ? nBlock = 1 : nBlock++;				}		cBlock = true;		cLine = 22 - Blocks.iMatrix[0];		cCol = 3;		bState = 0;		return true;	}			private function checkBlock(Line:Number, Col:Number, bMatrix:Array, iMatrix:Array):Boolean{		var i,j:Number;		for(i=0;i<iMatrix[0];i++)			for(j=0;j<iMatrix[1];j++)				if(bMatrix[i][j])					if(Matrix[Line+i][Col+j]!=0) return(false);		return(true);	}		private function GetRandomBlock():Number{		var i:Number;		i = Math.floor(Math.random()*7)+1;		return(i);	}						private function getKey():Number{		if (ToPause == true){			ToPause = false;			return(5);		} else if(ToStop == true){				TState=3;//Game over				return(0);			}		var i = 0;		if(Key.isDown(KUp)) i = 1;		else if(Key.isDown(KDown)) i = 2;		 	 else if(Key.isDown(KLeft)) i = 3;				  else if(Key.isDown(KRight)) i = 4;					   else if(Key.isDown(KeyPause.charCodeAt(0))) i = 5;					   		else if(Key.isDown(Key.ENTER)) i = 6;					  			else if(Key.isDown(KDrop)) i = 7;									else if(KeyTime.KeyPressed) i = 8;		return KeyTime.Check() ? i : 0;	}	}